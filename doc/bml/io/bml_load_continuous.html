<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of bml_load_continuous</title>
  <meta name="keywords" content="bml_load_continuous">
  <meta name="description" content="BML_LOAD_CONTINUOUS loads continuous raw from one or more files">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">bml</a> &gt; <a href="index.html">io</a> &gt; bml_load_continuous.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for bml/io&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>bml_load_continuous
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>BML_LOAD_CONTINUOUS loads continuous raw from one or more files</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [raw, file_raw_map] = bml_load_continuous(cfg) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> BML_LOAD_CONTINUOUS loads continuous raw from one or more files

 Use as 
   raw = bml_load_continuous(cfg)
   raw = bml_load_continuous(cfg.roi)
   [raw, file_raw_map] = bml_load_continuous(cfg)
   [raw, file_raw_map] = bml_load_continuous(cfg.roi)

 cfg is configuratin struct
   cfg.roi - ROI table with regions of interest to load
   cfg.channel - cellstr with channels to be selected
   cfg.electrode - ANNOT table with electrodes information. Should contain
                   variables 'channel' and 'electrode'. Optional.
   cfg.folder - overwrites info in cfg.roi
   cfg.chantype - overwrites info in cfg.roi
   cfg.filetype - overwrites info in cfg.roi
   cfg.Fs - overwrites info in cfg.roi
   cfg.timetol - double: time tolerance in seconds per sample. Defaults to 1e-6
   cfg.chantype - string
   cfg.dryrun - logical: should a dry-run test be performed? Defaults to false
   cfg.ft_feedback - string: default to 'no'. Defines verbosity of fieldtrip
           functions 
   cfg.discontinuous - string or logical: 
           * true or 'allow' to allow discontinous files to be loaded filling 
           the gap with zero-padding, if possible within timetol.
           * false or 'no' to issue an error if discontinous files are found
           * 'warn' to allow with a warning
   cfg.padval - value with which to pad if discontinuous files are loaded.
           Defualts to zero

 returns a continuous FT_DATATYPE_RAW and optionally a file-raw mapping

 -------------------------------------------------------------------------

 This function loads a fieldtrip data structure representing a raw continuous 
 in the form of a channels by times matrix (see FT_DATATYPE_RAW). The main
 argument is cfg.roi, ROI table with the synchronization file coordinates.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../bml/annot/bml_annot_intersect.html" class="code" title="function annot = bml_annot_intersect(cfg, x, y)">bml_annot_intersect</a>	BML_ANNOT_INTERSECT returns the intersection of two annotation tables</li><li><a href="../../bml/annot/bml_annot_table.html" class="code" title="function annot=bml_annot_table(x, description, x_var_name)">bml_annot_table</a>	BML_ANNOT_TABLE transforms a table into an annotations table [internal]</li><li><a href="../../bml/annot/bml_roi_table.html" class="code" title="function roi=bml_roi_table(x, description, x_var_name)">bml_roi_table</a>	BML_ROI_TABLE transforms a table into an ROI table [internal]</li><li><a href="../../bml/signal/bml_hstack.html" class="code" title="function [data] = bml_hstack(cfg, varargin)">bml_hstack</a>	BML_HSTACK concatenates multiple raw data structures by time</li><li><a href="../../bml/signal/bml_pad.html" class="code" title="function [padded, presamples, postsamples] = bml_pad(raw, starts, ends, padval)">bml_pad</a>	BML_PAD returns a padded version of the raw (crops if necessary)</li><li><a href="../../bml/sync/bml_crop_idx_valid.html" class="code" title="function [starts_idx,ends_idx] = bml_crop_idx_valid(cfg, varargin)">bml_crop_idx_valid</a>	BML_CROP_IDX_VALID calculates valid sample indices for a time window and file coordinates</li><li><a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>	BML_IDX2TIME calculates samples midpoint times from a index vector and file coordinates</li><li><a href="../../bml/sync/bml_sync_consolidate.html" class="code" title="function consolidated = bml_sync_consolidate(cfg)">bml_sync_consolidate</a>	BML_SYNC_CONSOLIDATE consolidates file synchronization chunks</li><li><a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>	BML_GETOPT gets the value from a configuration structure [internal]</li><li><a href="../../bml/utils/bml_getopt_single.html" class="code" title="function val = bml_getopt_single(varargin)">bml_getopt_single</a>	BML_GETOPT_SINGLE gets a single value from a configuration structure [internal]</li><li><a href="../../bml/utils/bml_map.html" class="code" title="function mapped = bml_map(element,domain,codomain)">bml_map</a>	BML_MAP maps elements based on given domain and codomain</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../bml/annot/bml_coding2annot.html" class="code" title="function annot = bml_coding2annot(cfg)">bml_coding2annot</a>	BML_CODING2ANNOT creates annot table from CodingMatrix</li><li><a href="bml_load_epoched.html" class="code" title="function [raw, loaded_epoch, file_raw_map] = bml_load_epoched(cfg)">bml_load_epoched</a>	BML_LOAD_EPOCHED loads an epoched raw from one or more files</li><li><a href="../../bml/sync/bml_sync_analog.html" class="code" title="function sync_roi = bml_sync_analog(cfg)">bml_sync_analog</a>	BML_SYNC_ANALOG time-aligns files based on a common analog sync channel</li><li><a href="../../bml/sync/bml_sync_check.html" class="code" title="function bml_sync_check(cfg)">bml_sync_check</a>	BML_SYNC_CHECK loads files in a synchronization roi table into praat</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [raw, file_raw_map] = bml_load_continuous(cfg)</a>
0002 
0003 <span class="comment">% BML_LOAD_CONTINUOUS loads continuous raw from one or more files</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Use as</span>
0006 <span class="comment">%   raw = bml_load_continuous(cfg)</span>
0007 <span class="comment">%   raw = bml_load_continuous(cfg.roi)</span>
0008 <span class="comment">%   [raw, file_raw_map] = bml_load_continuous(cfg)</span>
0009 <span class="comment">%   [raw, file_raw_map] = bml_load_continuous(cfg.roi)</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% cfg is configuratin struct</span>
0012 <span class="comment">%   cfg.roi - ROI table with regions of interest to load</span>
0013 <span class="comment">%   cfg.channel - cellstr with channels to be selected</span>
0014 <span class="comment">%   cfg.electrode - ANNOT table with electrodes information. Should contain</span>
0015 <span class="comment">%                   variables 'channel' and 'electrode'. Optional.</span>
0016 <span class="comment">%   cfg.folder - overwrites info in cfg.roi</span>
0017 <span class="comment">%   cfg.chantype - overwrites info in cfg.roi</span>
0018 <span class="comment">%   cfg.filetype - overwrites info in cfg.roi</span>
0019 <span class="comment">%   cfg.Fs - overwrites info in cfg.roi</span>
0020 <span class="comment">%   cfg.timetol - double: time tolerance in seconds per sample. Defaults to 1e-6</span>
0021 <span class="comment">%   cfg.chantype - string</span>
0022 <span class="comment">%   cfg.dryrun - logical: should a dry-run test be performed? Defaults to false</span>
0023 <span class="comment">%   cfg.ft_feedback - string: default to 'no'. Defines verbosity of fieldtrip</span>
0024 <span class="comment">%           functions</span>
0025 <span class="comment">%   cfg.discontinuous - string or logical:</span>
0026 <span class="comment">%           * true or 'allow' to allow discontinous files to be loaded filling</span>
0027 <span class="comment">%           the gap with zero-padding, if possible within timetol.</span>
0028 <span class="comment">%           * false or 'no' to issue an error if discontinous files are found</span>
0029 <span class="comment">%           * 'warn' to allow with a warning</span>
0030 <span class="comment">%   cfg.padval - value with which to pad if discontinuous files are loaded.</span>
0031 <span class="comment">%           Defualts to zero</span>
0032 <span class="comment">%</span>
0033 <span class="comment">% returns a continuous FT_DATATYPE_RAW and optionally a file-raw mapping</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% -------------------------------------------------------------------------</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% This function loads a fieldtrip data structure representing a raw continuous</span>
0038 <span class="comment">% in the form of a channels by times matrix (see FT_DATATYPE_RAW). The main</span>
0039 <span class="comment">% argument is cfg.roi, ROI table with the synchronization file coordinates.</span>
0040 <span class="comment">%</span>
0041 
0042 <span class="comment">%% READING ARGUMENTS</span>
0043 file_raw_map_vars = {<span class="string">'starts'</span>,<span class="string">'ends'</span>,<span class="string">'s1'</span>,<span class="string">'t1'</span>,<span class="string">'s2'</span>,<span class="string">'t2'</span>,<span class="string">'folder'</span>,<span class="string">'name'</span>,<span class="string">'nSamples'</span>,<span class="string">'Fs'</span>};
0044 
0045 <span class="keyword">if</span> istable(cfg)
0046   cfg = struct(<span class="string">'roi'</span>,cfg);
0047 <span class="keyword">end</span>
0048 
0049 folder        = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'folder'</span>);
0050 channel       = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'channel'</span>);
0051 chantype      = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'chantype'</span>);
0052 filetype      = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'filetype'</span>);
0053 Fs            = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'Fs'</span>);
0054 roi           = <a href="../../bml/annot/bml_annot_table.html" class="code" title="function annot=bml_annot_table(x, description, x_var_name)">bml_annot_table</a>(<a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'roi'</span>),<span class="string">'roi'</span>);
0055 timetol       = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'timetol'</span>,1e-5);
0056 dryrun        = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'dryrun'</span>,false);
0057 ft_feedback   = <a href="../../bml/utils/bml_getopt_single.html" class="code" title="function val = bml_getopt_single(varargin)">bml_getopt_single</a>(cfg,<span class="string">'ft_feedback'</span>,<span class="string">'no'</span>);
0058 discontinuous = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'discontinuous'</span>,<span class="string">'warn'</span>);
0059 padval        = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'padval'</span>,0);
0060 electrode     = <a href="../../bml/annot/bml_annot_table.html" class="code" title="function annot=bml_annot_table(x, description, x_var_name)">bml_annot_table</a>(<a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'electrode'</span>),<span class="string">'electrode'</span>);
0061 
0062 <span class="keyword">if</span> isempty(roi)
0063   raw=[];
0064   <span class="keyword">return</span>  
0065 <span class="keyword">end</span>
0066 roi = <a href="../../bml/annot/bml_roi_table.html" class="code" title="function roi=bml_roi_table(x, description, x_var_name)">bml_roi_table</a>(roi);
0067 
0068 <span class="keyword">if</span> islogical(discontinuous)
0069   <span class="keyword">if</span> discontinuous
0070     discontinuous = {<span class="string">'allow'</span>};
0071   <span class="keyword">else</span>
0072     discontinuous = {<span class="string">'no'</span>};
0073   <span class="keyword">end</span>
0074 <span class="keyword">end</span>
0075 
0076 <span class="comment">% %assert for no time overlaps between rows</span>
0077 <span class="comment">% cfg1=[]; cfg1.timetol = timetol;</span>
0078 <span class="comment">% if ~isempty(bml_annot_overlap(cfg1,roi))</span>
0079 <span class="comment">%   roi %printing table for user</span>
0080 <span class="comment">%   error('annotations in roi table overlap');</span>
0081 <span class="comment">% end</span>
0082 
0083 <span class="comment">%consolidating chunks of same file when possible</span>
0084 roi = <a href="../../bml/sync/bml_sync_consolidate.html" class="code" title="function consolidated = bml_sync_consolidate(cfg)">bml_sync_consolidate</a>(roi);
0085 
0086 <span class="comment">%removing zero length rois</span>
0087 roi = roi(roi.duration &gt; 0,:);
0088 
0089 <span class="keyword">if</span> ~isempty(folder)
0090   <span class="comment">%ToDo: combine cfg.folder with roi.folder in a smart way</span>
0091   roi.folder = repmat({folder},height(roi),1);
0092 <span class="keyword">end</span>
0093 
0094 <span class="comment">%using roi parameters if none specified in call</span>
0095 <span class="keyword">if</span> isempty(chantype) &amp;&amp; ismember(<span class="string">'chantype'</span>,roi.Properties.VariableNames)
0096   chantype  = cellstr(unique(roi.chantype));
0097 <span class="keyword">end</span>
0098 <span class="keyword">if</span> isempty(filetype) &amp;&amp; ismember(<span class="string">'filetype'</span>,roi.Properties.VariableNames)
0099   filetype  = cellstr(unique(roi.filetype));
0100 <span class="keyword">end</span>
0101 <span class="keyword">if</span> isempty(Fs) &amp;&amp; ismember(<span class="string">'Fs'</span>,roi.Properties.VariableNames)
0102   Fs        = unique(roi.Fs);
0103 <span class="keyword">end</span>
0104 assert(length(filetype)==1,<span class="string">'unique filetype required: %s'</span>,strjoin(filetype));
0105 assert(length(chantype)==1,<span class="string">'unique chantype required: %s'</span>,strjoin(chantype));
0106 assert(length(Fs)==1,<span class="string">'unique Fs required: %s'</span>,strjoin(string(num2str(Fs))));
0107 
0108 <span class="comment">%dealing with skip factors</span>
0109 skipFactor=1;
0110 chantype_split=strsplit(chantype{1},<span class="string">':'</span>);
0111 <span class="keyword">if</span> numel(chantype_split) == 2
0112   skipFactor=str2double(chantype_split{2});
0113 <span class="keyword">elseif</span> numel(chantype_split) &gt; 2
0114   ft_error(<span class="string">'Use '':'' to specify skipfactor, e.g. analog:10'</span>)
0115 <span class="keyword">end</span>
0116 
0117 <span class="comment">%selecting electrodes</span>
0118 <span class="keyword">if</span> ~isempty(electrode)
0119   assert(ismember(<span class="string">'channel'</span>,electrode.Properties.VariableNames),&quot;<span class="string">'channel'</span> variable required in cfg.electrode&quot;);
0120   assert(ismember(<span class="string">'electrode'</span>,electrode.Properties.VariableNames),&quot;<span class="string">'electrode'</span> variable required in cfg.electrode&quot;);
0121   <span class="comment">%checking electrodes for time, filetype and chantype</span>
0122   cfg1=[];
0123   cfg1.keep=<span class="string">'x'</span>;
0124   cfg1.warn=false;
0125   electrode = <a href="../../bml/annot/bml_annot_intersect.html" class="code" title="function annot = bml_annot_intersect(cfg, x, y)">bml_annot_intersect</a>(cfg1,electrode,<span class="keyword">...</span>
0126                   <a href="../../bml/annot/bml_annot_table.html" class="code" title="function annot=bml_annot_table(x, description, x_var_name)">bml_annot_table</a>(table(min(roi.starts),max(roi.ends))));
0127   assert(height(electrode)&gt;0,&quot;no electrode <span class="keyword">for</span> roi time&quot;);
0128   <span class="keyword">if</span> ismember(<span class="string">'filetype'</span>,electrode.Properties.VariableNames)
0129     electrode = electrode(strcmp(electrode.filetype,filetype),:);
0130     assert(height(electrode)&gt;0,&quot;incorrect filetype <span class="keyword">for</span> cfg.electrode&quot;);
0131   <span class="keyword">end</span>
0132   <span class="keyword">if</span> ismember(<span class="string">'chantype'</span>,electrode.Properties.VariableNames)
0133     electrode = electrode(<span class="keyword">...</span><span class="comment">  </span>
0134       contains(electrode.chantype,{chantype{1}},<span class="string">'IgnoreCase'</span>,true)|<span class="keyword">...</span>
0135       strcmp(electrode.chantype,<span class="string">'all'</span>)|<span class="keyword">...</span>
0136       strcmp(electrode.chantype,<span class="string">'any'</span>)|<span class="keyword">...</span>
0137       strcmp(electrode.chantype,<span class="string">'NA'</span>)|<span class="keyword">...</span>
0138       strcmp(electrode.chantype,<span class="string">''</span>),:);
0139     assert(height(electrode)&gt;0,&quot;incorrect chantype <span class="keyword">for</span> cfg.electrode&quot;);
0140   <span class="keyword">else</span>
0141     fprintf(&quot;electrode table has no chantype variable.\n&quot;)
0142   <span class="keyword">end</span>
0143   
0144   assert(numel(electrode.channel)==numel(unique(electrode.channel)),<span class="keyword">...</span>
0145       &quot;repeated electrode entries <span class="keyword">for</span> time/filetype/chantype&quot;);
0146 
0147   <span class="keyword">if</span> isempty(channel)
0148       channel = electrode.channel;
0149   <span class="keyword">end</span>
0150 <span class="keyword">end</span>
0151 
0152 <span class="comment">%optimizing channel selection for trellis files</span>
0153 <span class="keyword">if</span> ~isempty(channel) &amp;&amp; contains(filetype,&quot;trellis&quot;)
0154   chantype = {[<span class="string">'^('</span>,strjoin(channel,<span class="string">'|'</span>),<span class="string">')$'</span>]};
0155   <span class="keyword">if</span> skipFactor &gt; 1
0156     chantype{1} = [chantype{1},<span class="string">':'</span>,num2str(skipFactor)];
0157   <span class="keyword">end</span>
0158   channel=[];
0159 <span class="keyword">end</span>
0160 
0161 <span class="comment">%% LOAD FIRST FILE</span>
0162 
0163 <span class="comment">%saving mapping between raw and files</span>
0164 file_raw_map=roi(1,file_raw_map_vars);
0165 [s,e]=<a href="../../bml/sync/bml_crop_idx_valid.html" class="code" title="function [starts_idx,ends_idx] = bml_crop_idx_valid(cfg, varargin)">bml_crop_idx_valid</a>(roi(1,:));
0166 file_raw_map.s1=s;
0167 file_raw_map.s2=e;
0168 file_raw_map.t1=<a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>(roi(1,:),s);
0169 file_raw_map.t2=<a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>(roi(1,:),e);
0170 file_raw_map.raw1=1;
0171 file_raw_map.raw2=floor((e-s+1)/skipFactor);
0172 file_raw_map.skipFactor = skipFactor;
0173 
0174 <span class="comment">%loading first raw</span>
0175 cfg=[]; 
0176 cfg.chantype=chantype;
0177 cfg.trl = [ceil(s/skipFactor), floor(e/skipFactor), 0];
0178 cfg.dataset=fullfile(roi.folder{1},roi.name{1});
0179 cfg.feedback=ft_feedback;
0180 hdr = ft_read_header(cfg.dataset,<span class="string">'chantype'</span>,cfg.chantype);
0181 
0182 <span class="comment">%checking nomimal sampling frequencies</span>
0183 assert(hdr.Fs*skipFactor==roi.Fs(1),<span class="keyword">...</span>
0184   <span class="string">'File %s chantype %s has Fs %f, not %f as defined in cfg.roi'</span>,<span class="keyword">...</span>
0185   roi.name{1},strjoin(cfg.chantype),hdr.Fs,roi.Fs(1));
0186 
0187 <span class="keyword">if</span> ~dryrun
0188   raw = ft_preprocessing(cfg);
0189 <span class="keyword">else</span>
0190   raw = hdr;
0191   assert(raw.nSamples&gt;=floor(e/skipFactor),<span class="string">'index overflow s2=%i but nSample=%i'</span>,floor(e/skipFactor),raw.nSamples);
0192 <span class="keyword">end</span>
0193 
0194 <span class="comment">%selecting channels</span>
0195 <span class="keyword">if</span> ~isempty(channel)
0196   channel_selected=ft_channelselection(channel,raw.label);
0197   <span class="keyword">if</span> numel(channel_selected)==0
0198     error(<span class="string">'%s not present in raw %s \nAvailable channels are: %s'</span>,strjoin(channel),cfg.dataset,strjoin(raw.label));
0199   <span class="keyword">elseif</span> ~dryrun
0200     cfg=[]; cfg.channel=channel; cfg.feedback=ft_feedback;
0201     raw = ft_selectdata(cfg,raw);
0202   <span class="keyword">end</span>
0203 <span class="keyword">end</span>
0204 
0205 <span class="comment">% time = raw.time{1}+bml_idx2time(roi(1,:),s);</span>
0206 time = <a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>(roi(1,:),ceil(s/skipFactor):floor(e/skipFactor),skipFactor);
0207 raw.time{1} = time;
0208 <span class="keyword">if</span> abs(time(end)-<a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>(roi(1,:),floor(e/skipFactor),skipFactor)) &gt; timetol
0209   error(<span class="string">'timetol violated'</span>)
0210 <span class="keyword">end</span>
0211 
0212 <span class="comment">%% LOAD OTHER FILES (if present)</span>
0213 <span class="keyword">for</span> i=2:height(roi)
0214   
0215   <span class="comment">%saving mapping between raw and files</span>
0216   row=roi(i,file_raw_map_vars);
0217   [s,e]=<a href="../../bml/sync/bml_crop_idx_valid.html" class="code" title="function [starts_idx,ends_idx] = bml_crop_idx_valid(cfg, varargin)">bml_crop_idx_valid</a>(roi(i,:));
0218   row.s1=s;
0219   row.s2=e;
0220   row.t1=<a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>(roi(i,:),s);
0221   row.t2=<a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>(roi(i,:),e);
0222   row.raw1=max(file_raw_map.raw2)+1;
0223   row.raw2=floor((e-s)/skipFactor)+row.raw1;
0224   row.skipFactor = skipFactor;
0225   
0226   <span class="comment">%loading next raw</span>
0227   cfg=[]; 
0228   cfg.chantype=chantype;
0229   cfg.trl = [ceil(s/skipFactor), floor(e/skipFactor), 0];
0230   cfg.dataset=fullfile(roi.folder{i},roi.name{i});
0231   cfg.feedback=ft_feedback;
0232   <span class="keyword">if</span> ~dryrun
0233     next_raw = ft_preprocessing(cfg);
0234   <span class="keyword">else</span>
0235     next_raw = ft_read_header(cfg.dataset,<span class="string">'chantype'</span>,cfg.chantype);
0236     assert(next_raw.nSamples&gt;=floor(e/skipFactor),<span class="string">'index overflow s2=%i but nSample=%i'</span>,floor(e/skipFactor),next_raw.nSamples);
0237   <span class="keyword">end</span>
0238   
0239   <span class="keyword">if</span> ~isempty(channel)
0240     <span class="keyword">if</span> isstring(channel); channel = {char(channel)}; <span class="keyword">end</span>
0241     <span class="keyword">if</span> ~dryrun
0242       cfg=[]; cfg.channel=channel; cfg.feedback=ft_feedback;
0243       next_raw = ft_selectdata(cfg,next_raw);
0244     <span class="keyword">end</span>
0245   <span class="keyword">end</span>
0246     
0247   <span class="comment">%next_time = next_raw.time{1}+bml_idx2time(roi(i,:),s);</span>
0248   next_time = <a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>(roi(i,:),ceil(s/skipFactor):floor(e/skipFactor),skipFactor);
0249   next_raw.time{1} = next_time;
0250   assert(abs(next_time(end)-<a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>(roi(i,:),floor(e/skipFactor),skipFactor)) &lt; timetol, <span class="string">'timetol violated'</span>);
0251  
0252   <span class="comment">%verifying contiguity</span>
0253   delta_t = next_time(1) - time(end) - skipFactor/Fs;
0254   <span class="keyword">if</span> abs(delta_t) &gt; timetol <span class="comment">%non contiguous files</span>
0255     <span class="keyword">if</span> ~ismember(discontinuous,{<span class="string">'allow'</span>,<span class="string">'warn'</span>})
0256       roi
0257       error(&quot;To concateneting discontinuous rois use cfg.discontinuous=<span class="string">'allow'</span>&quot;);
0258     <span class="keyword">end</span>  
0259     
0260     delta_s = delta_t*Fs/skipFactor;
0261     delta_s_int = round(delta_s);
0262     assert(delta_s&gt;0,&quot;overlaping rois can't be concatenated&quot;); 
0263 
0264     <span class="keyword">if</span> abs(delta_s_int - delta_s) &lt; timetol*Fs/skipFactor
0265       <span class="keyword">if</span> ismember(discontinuous,{<span class="string">'warn'</span>})
0266         warning(&quot;concatenating discontinous files <span class="comment">%i samples added&quot;,delta_s_int);</span>
0267       <span class="keyword">end</span>
0268       <span class="keyword">if</span> ~dryrun             
0269         <span class="comment">%zero padding the end of the previous raw</span>
0270         starts = raw.time{1}(1) - 0.5*skipFactor/Fs;
0271         ends = next_time(1) + 0.5*skipFactor/Fs;
0272         [raw, ~, post] = <a href="../../bml/signal/bml_pad.html" class="code" title="function [padded, presamples, postsamples] = bml_pad(raw, starts, ends, padval)">bml_pad</a>(raw,starts,ends,padval);
0273         
0274         <span class="comment">%correcting raw mapping due to zero padding</span>
0275         <span class="comment">%the starts of next file in raw coordinates is delayed by post</span>
0276         row.raw1=max(file_raw_map.raw2)+1+post;
0277         row.raw2=floor((e-s)/skipFactor)+row.raw1;
0278       <span class="keyword">else</span>
0279         time = [time,time(end)+(1:delta_s_int)*skipFactor/Fs];
0280       <span class="keyword">end</span>
0281     <span class="keyword">else</span>
0282         roi
0283       error(<span class="string">'can''t concatenate discontinuous files within timetol'</span>);
0284     <span class="keyword">end</span> 
0285   <span class="keyword">end</span>
0286     
0287   <span class="keyword">if</span> ~dryrun
0288     cfg1=[]; cfg1.timetol = timetol; cfg1.timeref = <span class="string">'common'</span>;
0289     raw = <a href="../../bml/signal/bml_hstack.html" class="code" title="function [data] = bml_hstack(cfg, varargin)">bml_hstack</a>(cfg1, raw, next_raw);
0290     time = raw.time{1};
0291   <span class="keyword">else</span>
0292     time = [time next_time];
0293   <span class="keyword">end</span>
0294   
0295   file_raw_map = [file_raw_map;row];
0296 <span class="keyword">end</span>
0297 
0298 <span class="keyword">if</span> dryrun
0299   raw = [];
0300 <span class="keyword">elseif</span> ~isempty(electrode)
0301   <span class="comment">%changing labels from channels to electrodes</span>
0302     raw.label = <a href="../../bml/utils/bml_map.html" class="code" title="function mapped = bml_map(element,domain,codomain)">bml_map</a>(raw.label,electrode.channel,electrode.electrode);
0303 <span class="keyword">end</span>
0304 
0305 file_raw_map = <a href="../../bml/annot/bml_roi_table.html" class="code" title="function roi=bml_roi_table(x, description, x_var_name)">bml_roi_table</a>(file_raw_map);
0306 
0307 
0308 
0309</pre></div>
<hr><address>Generated on Tue 20-Feb-2018 13:18:04 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>