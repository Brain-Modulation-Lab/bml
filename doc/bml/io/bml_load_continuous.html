<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of bml_load_continuous</title>
  <meta name="keywords" content="bml_load_continuous">
  <meta name="description" content="BML_LOAD_CONTINUOUS loads continuous raw from one or more files">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">bml</a> &gt; <a href="index.html">io</a> &gt; bml_load_continuous.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for bml\io&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>bml_load_continuous
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>BML_LOAD_CONTINUOUS loads continuous raw from one or more files</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [raw, file_raw_map] = bml_load_continuous(cfg) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> BML_LOAD_CONTINUOUS loads continuous raw from one or more files

 Use as 
   raw = bml_load_continuous(cfg)
   raw = bml_load_continuous(cfg.roi)
   [raw, file_raw_map] = bml_load_continuous(cfg)
   [raw, file_raw_map] = bml_load_continuous(cfg.roi)

 cfg is configuratin struct
   cfg.roi - ROI table with regions of interest to load
   cfg.channel - cellstr with channels to be selected
   cfg.electrode - ANNOT table with electrodes information. Should contain
                   variables 'channel' and 'electrode'. Optional.
   cfg.folder - overwrites info in cfg.roi
   cfg.chantype - string, overwrites info in cfg.roi
   cfg.filetype - overwrites info in cfg.roi
   cfg.Fs - overwrites info in cfg.roi
   cfg.timetol - double: time tolerance in seconds per sample. Defaults to 1e-5s
           this time tolerance relates to sample contiguity, i.e.
           intrinsic time tolerance (between samples of same stream)
   cfg.timetol_consolidate - double: consolidation time tolerance. Defaults to 1e-3s
           this time tolerance relates to the sync consolidation process.
           extrinsic time tolerance (between samples of different strams)
   cfg.dryrun - logical: should a dry-run test be performed? Defaults to false
   cfg.ft_feedback - string: default to 'no'. Defines verbosity of fieldtrip
           functions 
   cfg.discontinuous - string or logical: 
           * true or 'allow' to allow discontinous files to be loaded filling 
           the gap with zero-padding, if possible within timetol.
           * false or 'no' to issue an error if discontinous files are found
           * 'warn' to allow with a warning
   cfg.match_labels - logical, indicates if labels of all files should be
           the same. Defaulst to true. If false a warning will be issued
           when concatenating files with different labels. 
   cfg.padval - value with which to pad if discontinuous files are loaded.
           Defualts to zero

 returns a continuous FT_DATATYPE_RAW and optionally a file-raw mapping

 -------------------------------------------------------------------------

 This function loads a fieldtrip data structure representing a raw continuous 
 in the form of a channels by times matrix (see FT_DATATYPE_RAW). The main
 argument is cfg.roi, ROI table with the synchronization file coordinates.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../bml/annot/bml_annot_intersect.html" class="code" title="function annot = bml_annot_intersect(cfg, x, y)">bml_annot_intersect</a>	BML_ANNOT_INTERSECT returns the intersection of two annotation tables</li><li><a href="../../bml/annot/bml_annot_table.html" class="code" title="function annot=bml_annot_table(x, description, x_var_name)">bml_annot_table</a>	BML_ANNOT_TABLE transforms a table into an annotations table [internal]</li><li><a href="../../bml/annot/bml_roi_table.html" class="code" title="function roi=bml_roi_table(x, description, x_var_name)">bml_roi_table</a>	BML_ROI_TABLE transforms a table into an ROI table [internal]</li><li><a href="../../bml/signal/bml_crop_idx_valid.html" class="code" title="function [starts_idx,ends_idx] = bml_crop_idx_valid(cfg, varargin)">bml_crop_idx_valid</a>	BML_CROP_IDX_VALID calculates valid sample indices for a time window and file coordinates</li><li><a href="../../bml/signal/bml_hstack.html" class="code" title="function [data] = bml_hstack(cfg, varargin)">bml_hstack</a>	BML_HSTACK concatenates multiple raw data structures by time</li><li><a href="../../bml/signal/bml_pad.html" class="code" title="function [padded, presamples, postsamples] = bml_pad(raw, starts, ends, padval)">bml_pad</a>	BML_PAD returns a padded version of the raw (crops if necessary)</li><li><a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>	BML_IDX2TIME calculates samples midpoint times from a index vector and file coordinates</li><li><a href="../../bml/sync/bml_sync_consolidate.html" class="code" title="function consolidated = bml_sync_consolidate(cfg)">bml_sync_consolidate</a>	BML_SYNC_CONSOLIDATE consolidates synchronization chunks</li><li><a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>	BML_GETOPT gets the value from a configuration structure [internal]</li><li><a href="../../bml/utils/bml_getopt_single.html" class="code" title="function val = bml_getopt_single(varargin)">bml_getopt_single</a>	BML_GETOPT_SINGLE gets a single value from a configuration structure [internal]</li><li><a href="../../bml/utils/bml_map.html" class="code" title="function mapped = bml_map(element,domain,codomain,non_domain)">bml_map</a>	BML_MAP maps elements based on given domain and codomain</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../bml/annot/bml_coding2annot.html" class="code" title="function annot = bml_coding2annot(cfg)">bml_coding2annot</a>	BML_CODING2ANNOT creates annotation table from CodingMatrix</li><li><a href="bml_load_epoched.html" class="code" title="function [raw, loaded_epoch, file_raw_map] = bml_load_epoched(cfg)">bml_load_epoched</a>	BML_LOAD_EPOCHED loads an epoched raw from one or more files</li><li><a href="../../bml/sync/bml_sync_analog.html" class="code" title="function sync_roi = bml_sync_analog(cfg)">bml_sync_analog</a>	BML_SYNC_ANALOG time-aligns files based on a common analog sync channel</li><li><a href="../../bml/sync/bml_sync_audio_event.html" class="code" title="function sync_roi = bml_sync_audio_event(cfg)">bml_sync_audio_event</a>	bml_sync_audio_event synchronizes zoom audio files according to</li><li><a href="../../bml/sync/bml_sync_check.html" class="code" title="function bml_sync_check(cfg)">bml_sync_check</a>	BML_SYNC_CHECK loads files in a synchronization roi table into praat</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [raw, file_raw_map] = bml_load_continuous(cfg)</a>
0002 
0003 <span class="comment">% BML_LOAD_CONTINUOUS loads continuous raw from one or more files</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Use as</span>
0006 <span class="comment">%   raw = bml_load_continuous(cfg)</span>
0007 <span class="comment">%   raw = bml_load_continuous(cfg.roi)</span>
0008 <span class="comment">%   [raw, file_raw_map] = bml_load_continuous(cfg)</span>
0009 <span class="comment">%   [raw, file_raw_map] = bml_load_continuous(cfg.roi)</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% cfg is configuratin struct</span>
0012 <span class="comment">%   cfg.roi - ROI table with regions of interest to load</span>
0013 <span class="comment">%   cfg.channel - cellstr with channels to be selected</span>
0014 <span class="comment">%   cfg.electrode - ANNOT table with electrodes information. Should contain</span>
0015 <span class="comment">%                   variables 'channel' and 'electrode'. Optional.</span>
0016 <span class="comment">%   cfg.folder - overwrites info in cfg.roi</span>
0017 <span class="comment">%   cfg.chantype - string, overwrites info in cfg.roi</span>
0018 <span class="comment">%   cfg.filetype - overwrites info in cfg.roi</span>
0019 <span class="comment">%   cfg.Fs - overwrites info in cfg.roi</span>
0020 <span class="comment">%   cfg.timetol - double: time tolerance in seconds per sample. Defaults to 1e-5s</span>
0021 <span class="comment">%           this time tolerance relates to sample contiguity, i.e.</span>
0022 <span class="comment">%           intrinsic time tolerance (between samples of same stream)</span>
0023 <span class="comment">%   cfg.timetol_consolidate - double: consolidation time tolerance. Defaults to 1e-3s</span>
0024 <span class="comment">%           this time tolerance relates to the sync consolidation process.</span>
0025 <span class="comment">%           extrinsic time tolerance (between samples of different strams)</span>
0026 <span class="comment">%   cfg.dryrun - logical: should a dry-run test be performed? Defaults to false</span>
0027 <span class="comment">%   cfg.ft_feedback - string: default to 'no'. Defines verbosity of fieldtrip</span>
0028 <span class="comment">%           functions</span>
0029 <span class="comment">%   cfg.discontinuous - string or logical:</span>
0030 <span class="comment">%           * true or 'allow' to allow discontinous files to be loaded filling</span>
0031 <span class="comment">%           the gap with zero-padding, if possible within timetol.</span>
0032 <span class="comment">%           * false or 'no' to issue an error if discontinous files are found</span>
0033 <span class="comment">%           * 'warn' to allow with a warning</span>
0034 <span class="comment">%   cfg.match_labels - logical, indicates if labels of all files should be</span>
0035 <span class="comment">%           the same. Defaulst to true. If false a warning will be issued</span>
0036 <span class="comment">%           when concatenating files with different labels.</span>
0037 <span class="comment">%   cfg.padval - value with which to pad if discontinuous files are loaded.</span>
0038 <span class="comment">%           Defualts to zero</span>
0039 <span class="comment">%</span>
0040 <span class="comment">% returns a continuous FT_DATATYPE_RAW and optionally a file-raw mapping</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% -------------------------------------------------------------------------</span>
0043 <span class="comment">%</span>
0044 <span class="comment">% This function loads a fieldtrip data structure representing a raw continuous</span>
0045 <span class="comment">% in the form of a channels by times matrix (see FT_DATATYPE_RAW). The main</span>
0046 <span class="comment">% argument is cfg.roi, ROI table with the synchronization file coordinates.</span>
0047 <span class="comment">%</span>
0048 
0049 <span class="comment">%% READING ARGUMENTS</span>
0050 file_raw_map_vars = {<span class="string">'starts'</span>,<span class="string">'ends'</span>,<span class="string">'s1'</span>,<span class="string">'t1'</span>,<span class="string">'s2'</span>,<span class="string">'t2'</span>,<span class="string">'folder'</span>,<span class="string">'name'</span>,<span class="string">'nSamples'</span>,<span class="string">'Fs'</span>};
0051 
0052 <span class="keyword">if</span> istable(cfg)
0053   cfg = struct(<span class="string">'roi'</span>,cfg);
0054 <span class="keyword">end</span>
0055 
0056 folder        = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'folder'</span>);
0057 channel       = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'channel'</span>);
0058 chantype      = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'chantype'</span>);
0059 filetype      = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'filetype'</span>);
0060 Fs            = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'Fs'</span>);
0061 roi           = <a href="../../bml/annot/bml_annot_table.html" class="code" title="function annot=bml_annot_table(x, description, x_var_name)">bml_annot_table</a>(<a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'roi'</span>),<span class="string">'roi'</span>);
0062 timetol       = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'timetol'</span>,1e-5);
0063 timetol_cons  = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'timetol_consolidate'</span>,1e-3);
0064 dryrun        = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'dryrun'</span>,false);
0065 ft_feedback   = <a href="../../bml/utils/bml_getopt_single.html" class="code" title="function val = bml_getopt_single(varargin)">bml_getopt_single</a>(cfg,<span class="string">'ft_feedback'</span>,<span class="string">'no'</span>);
0066 discontinuous = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'discontinuous'</span>,<span class="string">'warn'</span>);
0067 padval        = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'padval'</span>,0);
0068 match_labels  = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'match_labels'</span>,true);
0069 
0070 electrode     = <a href="../../bml/utils/bml_getopt.html" class="code" title="function val = bml_getopt(opt, key, default, emptymeaningful)">bml_getopt</a>(cfg,<span class="string">'electrode'</span>,[]);
0071 <span class="keyword">if</span> istable(electrode) &amp;&amp; isempty(electrode); error(<span class="string">'Empty electrode table'</span>); <span class="keyword">end</span>
0072 electrode     = <a href="../../bml/annot/bml_annot_table.html" class="code" title="function annot=bml_annot_table(x, description, x_var_name)">bml_annot_table</a>(electrode,<span class="string">'electrode'</span>);
0073 
0074 <span class="keyword">if</span> isempty(roi)
0075   raw=[];
0076   file_raw_map=[];
0077   <span class="keyword">return</span>  
0078 <span class="keyword">end</span>
0079 roi = <a href="../../bml/annot/bml_roi_table.html" class="code" title="function roi=bml_roi_table(x, description, x_var_name)">bml_roi_table</a>(roi);
0080 
0081 <span class="keyword">if</span> islogical(discontinuous)
0082   <span class="keyword">if</span> discontinuous
0083     discontinuous = {<span class="string">'allow'</span>};
0084   <span class="keyword">else</span>
0085     discontinuous = {<span class="string">'no'</span>};
0086   <span class="keyword">end</span>
0087 <span class="keyword">end</span>
0088 
0089 <span class="comment">%consolidating chunks of same file when possible</span>
0090 cfg1=[];
0091 cfg1.roi=roi;
0092 cfg1.timetol=timetol_cons;
0093 roi = <a href="../../bml/sync/bml_sync_consolidate.html" class="code" title="function consolidated = bml_sync_consolidate(cfg)">bml_sync_consolidate</a>(cfg1);
0094 
0095 <span class="comment">%removing zero length rois</span>
0096 roi = roi(roi.duration &gt; 0,:);
0097 
0098 <span class="keyword">if</span> ~isempty(folder)
0099   <span class="comment">%ToDo: combine cfg.folder with roi.folder in a smart way</span>
0100   roi.folder = repmat({folder},height(roi),1);
0101 <span class="keyword">end</span>
0102 
0103 <span class="comment">%using roi parameters if none specified in call</span>
0104 <span class="keyword">if</span> isempty(chantype) &amp;&amp; ismember(<span class="string">'chantype'</span>,roi.Properties.VariableNames)
0105   chantype  = cellstr(unique(roi.chantype));
0106 <span class="keyword">end</span>
0107 <span class="keyword">if</span> isempty(filetype) &amp;&amp; ismember(<span class="string">'filetype'</span>,roi.Properties.VariableNames)
0108   filetype  = cellstr(unique(roi.filetype));
0109 <span class="keyword">end</span>
0110 <span class="keyword">if</span> isempty(Fs) &amp;&amp; ismember(<span class="string">'Fs'</span>,roi.Properties.VariableNames)
0111   Fs        = unique(roi.Fs);
0112 <span class="keyword">end</span>
0113 assert(length(filetype)==1,<span class="string">'unique filetype required: %s'</span>,strjoin(filetype));
0114 assert(length(chantype)==1,<span class="string">'unique chantype required: %s'</span>,strjoin(chantype));
0115 assert(length(Fs)==1,<span class="string">'unique Fs required: %s'</span>,strjoin(string(num2str(Fs))));
0116 
0117 <span class="comment">%dealing with skip factors</span>
0118 skipFactor=1;
0119 chantype_split=strsplit(chantype{1},<span class="string">':'</span>);
0120 <span class="keyword">if</span> numel(chantype_split) == 2
0121   skipFactor=str2double(chantype_split{2});
0122 <span class="keyword">elseif</span> numel(chantype_split) &gt; 2
0123   ft_error(<span class="string">'Use '':'' to specify skipfactor, e.g. analog:10'</span>)
0124 <span class="keyword">end</span>
0125 
0126 <span class="comment">%selecting electrodes</span>
0127 <span class="keyword">if</span> ~isempty(electrode)
0128   assert(ismember(<span class="string">'channel'</span>,electrode.Properties.VariableNames),&quot;<span class="string">'channel'</span> variable required in cfg.electrode&quot;);
0129   assert(ismember(<span class="string">'electrode'</span>,electrode.Properties.VariableNames),&quot;<span class="string">'electrode'</span> variable required in cfg.electrode&quot;);
0130   <span class="comment">%checking electrodes for time, filetype and chantype</span>
0131   cfg1=[];
0132   cfg1.keep=<span class="string">'x'</span>;
0133   cfg1.warn=false;
0134   electrode = <a href="../../bml/annot/bml_annot_intersect.html" class="code" title="function annot = bml_annot_intersect(cfg, x, y)">bml_annot_intersect</a>(cfg1,electrode,<span class="keyword">...</span>
0135                   <a href="../../bml/annot/bml_annot_table.html" class="code" title="function annot=bml_annot_table(x, description, x_var_name)">bml_annot_table</a>(table(min(roi.starts),max(roi.ends))));
0136   assert(height(electrode)&gt;0,&quot;no electrode <span class="keyword">for</span> roi time&quot;);
0137   <span class="keyword">if</span> ismember(<span class="string">'filetype'</span>,electrode.Properties.VariableNames)
0138     electrode = electrode(strcmp(electrode.filetype,filetype),:);
0139     assert(height(electrode)&gt;0,&quot;incorrect filetype <span class="keyword">for</span> cfg.electrode&quot;);
0140   <span class="keyword">end</span>
0141   <span class="keyword">if</span> ismember(<span class="string">'chantype'</span>,electrode.Properties.VariableNames)
0142     electrode = electrode(<span class="keyword">...</span><span class="comment">  </span>
0143       contains(electrode.chantype,{chantype{1}},<span class="string">'IgnoreCase'</span>,true)|<span class="keyword">...</span>
0144       strcmp(electrode.chantype,<span class="string">'all'</span>)|<span class="keyword">...</span>
0145       strcmp(electrode.chantype,<span class="string">'any'</span>)|<span class="keyword">...</span>
0146       strcmp(electrode.chantype,<span class="string">'NA'</span>)|<span class="keyword">...</span>
0147       strcmp(electrode.chantype,<span class="string">''</span>),:);
0148     assert(height(electrode)&gt;0,&quot;incorrect chantype <span class="keyword">for</span> cfg.electrode&quot;);
0149   <span class="keyword">else</span>
0150     fprintf(&quot;electrode table has no chantype variable.\n&quot;)
0151   <span class="keyword">end</span>
0152   
0153   assert(numel(electrode.channel)==numel(unique(electrode.channel)),<span class="keyword">...</span>
0154       &quot;repeated electrode entries <span class="keyword">for</span> time/filetype/chantype&quot;);
0155 
0156   <span class="keyword">if</span> isempty(channel)
0157       channel = electrode.channel;
0158   <span class="keyword">end</span>
0159 <span class="keyword">end</span>
0160 
0161 <span class="comment">%optimizing channel selection for trellis files</span>
0162 <span class="keyword">if</span> ~isempty(channel) &amp;&amp; contains(filetype,&quot;trellis&quot;) &amp;&amp; ~contains(filetype,&quot;.nf6&quot;)
0163   chantype = {[<span class="string">'^('</span>,strjoin(channel,<span class="string">'|'</span>),<span class="string">')$'</span>]};
0164   <span class="keyword">if</span> skipFactor &gt; 1
0165     chantype{1} = [chantype{1},<span class="string">':'</span>,num2str(skipFactor)];
0166   <span class="keyword">end</span>
0167   channel=[];
0168 <span class="keyword">end</span>
0169 
0170 <span class="comment">%% LOAD FIRST FILE</span>
0171 
0172 <span class="comment">%saving mapping between raw and files</span>
0173 file_raw_map=roi(1,file_raw_map_vars);
0174 [s,e]=<a href="../../bml/signal/bml_crop_idx_valid.html" class="code" title="function [starts_idx,ends_idx] = bml_crop_idx_valid(cfg, varargin)">bml_crop_idx_valid</a>(roi(1,:));
0175 file_raw_map.s1=s;
0176 file_raw_map.s2=e;
0177 file_raw_map.t1=<a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>(roi(1,:),s);
0178 file_raw_map.t2=<a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>(roi(1,:),e);
0179 file_raw_map.raw1=1;
0180 file_raw_map.raw2=floor((e-s+1)/skipFactor);
0181 file_raw_map.skipFactor = skipFactor;
0182 
0183 <span class="comment">%loading first raw</span>
0184 cfg=[]; 
0185 cfg.chantype=chantype;
0186 cfg.channel = channel;
0187 cfg.trl = [ceil(s/skipFactor), floor(e/skipFactor), 0];
0188 cfg.dataset=fullfile(roi.folder{1},roi.name{1});
0189 cfg.feedback=ft_feedback;
0190 cfg.trackcallinfo=false;
0191 <span class="keyword">if</span> isempty(cfg.chantype) || strcmp(cfg.chantype,{<span class="string">'all'</span>})
0192     hdr = ft_read_header(cfg.dataset,<span class="string">'chantype'</span>,[]);
0193     cfg.chantype = [];
0194     <span class="comment">%checking nomimal sampling frequencies</span>
0195     assert(hdr.Fs*skipFactor==roi.Fs(1),<span class="keyword">...</span>
0196         <span class="string">'File %s has Fs %f, not %f as defined in cfg.roi'</span>,<span class="keyword">...</span>
0197         roi.name{1},hdr.Fs,roi.Fs(1));
0198 <span class="keyword">else</span>
0199     hdr = ft_read_header(cfg.dataset,<span class="string">'chantype'</span>,cfg.chantype);
0200     <span class="comment">%checking nomimal sampling frequencies</span>
0201     assert(hdr.Fs*skipFactor==roi.Fs(1),<span class="keyword">...</span>
0202         <span class="string">'File %s chantype %s has Fs %f, not %f as defined in cfg.roi'</span>,<span class="keyword">...</span>
0203         roi.name{1},strjoin(cfg.chantype),hdr.Fs,roi.Fs(1));
0204 <span class="keyword">end</span>
0205 
0206 
0207 <span class="keyword">if</span> ~dryrun
0208   raw = ft_preprocessing(cfg);
0209 <span class="keyword">else</span>
0210   raw = hdr;
0211   assert(raw.nSamples&gt;=floor(e/skipFactor),<span class="string">'index overflow s2=%i but nSample=%i'</span>,floor(e/skipFactor),raw.nSamples);
0212 <span class="keyword">end</span>
0213 
0214 <span class="comment">%selecting channels</span>
0215 <span class="keyword">if</span> ~isempty(channel)
0216   channel_selected=ft_channelselection(channel,raw.label);
0217   <span class="keyword">if</span> numel(channel_selected)==0
0218     error(<span class="string">'%s not present in raw %s \nAvailable channels are: %s'</span>,strjoin(channel),cfg.dataset,strjoin(raw.label));
0219   <span class="keyword">elseif</span> ~dryrun
0220     cfg=[]; 
0221     cfg.channel=channel; 
0222     cfg.feedback=ft_feedback;
0223     cfg.trackcallinfo=false;
0224     raw = ft_selectdata(cfg,raw);
0225   <span class="keyword">end</span>
0226 <span class="keyword">end</span>
0227 
0228 <span class="comment">% time = raw.time{1}+bml_idx2time(roi(1,:),s);</span>
0229 time = <a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>(roi(1,:),ceil(s/skipFactor):floor(e/skipFactor),skipFactor);
0230 raw.time{1} = time;
0231 <span class="keyword">if</span> abs(time(end)-<a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>(roi(1,:),floor(e/skipFactor),skipFactor)) &gt; timetol
0232   error(<span class="string">'timetol violated'</span>)
0233 <span class="keyword">end</span>
0234 
0235 <span class="comment">%% LOAD OTHER FILES (if present)</span>
0236 <span class="keyword">for</span> i=2:height(roi)
0237   
0238   <span class="comment">%saving mapping between raw and files</span>
0239   row=roi(i,file_raw_map_vars);
0240   [s,e]=<a href="../../bml/signal/bml_crop_idx_valid.html" class="code" title="function [starts_idx,ends_idx] = bml_crop_idx_valid(cfg, varargin)">bml_crop_idx_valid</a>(roi(i,:));
0241   row.s1=s;
0242   row.s2=e;
0243   row.t1=<a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>(roi(i,:),s);
0244   row.t2=<a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>(roi(i,:),e);
0245   row.raw1=max(file_raw_map.raw2)+1;
0246   row.raw2=floor((e-s)/skipFactor)+row.raw1;
0247   row.skipFactor = skipFactor;
0248   
0249   <span class="comment">%loading next raw</span>
0250   cfg=[]; 
0251   cfg.chantype=chantype;
0252   cfg.trl = [ceil(s/skipFactor), floor(e/skipFactor), 0];
0253   cfg.dataset=fullfile(roi.folder{i},roi.name{i});
0254   cfg.feedback=ft_feedback;
0255   cfg.trackcallinfo=false;
0256   <span class="keyword">if</span> ~dryrun
0257     next_raw = ft_preprocessing(cfg);
0258   <span class="keyword">else</span>
0259     next_raw = ft_read_header(cfg.dataset,<span class="string">'chantype'</span>,cfg.chantype);
0260     assert(next_raw.nSamples&gt;=floor(e/skipFactor),<span class="string">'index overflow s2=%i but nSample=%i'</span>,floor(e/skipFactor),next_raw.nSamples);
0261   <span class="keyword">end</span>
0262   
0263   <span class="keyword">if</span> ~isempty(channel)
0264     <span class="keyword">if</span> isstring(channel); channel = {char(channel)}; <span class="keyword">end</span>
0265     <span class="keyword">if</span> ~dryrun
0266       cfg=[]; cfg.channel=channel; cfg.feedback=ft_feedback;
0267       cfg.trackcallinfo=false;
0268       next_raw = ft_selectdata(cfg,next_raw);
0269     <span class="keyword">end</span>
0270   <span class="keyword">end</span>
0271     
0272   <span class="comment">%next_time = next_raw.time{1}+bml_idx2time(roi(i,:),s);</span>
0273   next_time = <a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>(roi(i,:),ceil(s/skipFactor):floor(e/skipFactor),skipFactor);
0274   next_raw.time{1} = next_time;
0275   assert(abs(next_time(end)-<a href="../../bml/sync/bml_idx2time.html" class="code" title="function time=bml_idx2time(cfg, idx, skipFactor)">bml_idx2time</a>(roi(i,:),floor(e/skipFactor),skipFactor)) &lt; timetol, <span class="string">'timetol violated'</span>);
0276  
0277   <span class="comment">%verifying contiguity</span>
0278   delta_t = next_time(1) - time(end) - skipFactor/Fs;
0279   <span class="keyword">if</span> abs(delta_t) &gt; timetol <span class="comment">%non contiguous files</span>
0280     <span class="keyword">if</span> ~ismember(discontinuous,{<span class="string">'allow'</span>,<span class="string">'warn'</span>})
0281       roi
0282       error(&quot;To concateneting discontinuous rois use cfg.discontinuous=<span class="string">'allow'</span>&quot;);
0283     <span class="keyword">end</span>  
0284     
0285     delta_s = delta_t*Fs/skipFactor;
0286     delta_s_int = round(delta_s);
0287     assert(abs(delta_t)&lt;timetol,&quot;rois overlap by <span class="comment">%f &gt; tolerance = %f correct or increase tolerance&quot;,delta_t,timetol);</span>
0288 
0289     <span class="keyword">if</span> abs(delta_s_int - delta_s) &lt; timetol*Fs/skipFactor
0290       <span class="keyword">if</span> ismember(discontinuous,{<span class="string">'warn'</span>})
0291         warning(&quot;concatenating discontinous files <span class="comment">%i samples added&quot;,delta_s_int);</span>
0292       <span class="keyword">end</span>
0293       <span class="keyword">if</span> ~dryrun             
0294         <span class="comment">%zero padding the end of the previous raw</span>
0295         starts = raw.time{1}(1) - 0.5*skipFactor/Fs;
0296         ends = next_time(1) + 0.5*skipFactor/Fs;
0297         [raw, ~, post] = <a href="../../bml/signal/bml_pad.html" class="code" title="function [padded, presamples, postsamples] = bml_pad(raw, starts, ends, padval)">bml_pad</a>(raw,starts,ends,padval);
0298         
0299         <span class="comment">%correcting raw mapping due to zero padding</span>
0300         <span class="comment">%the starts of next file in raw coordinates is delayed by post</span>
0301         row.raw1=max(file_raw_map.raw2)+1+post;
0302         row.raw2=floor((e-s)/skipFactor)+row.raw1;
0303       <span class="keyword">else</span>
0304         time = [time,time(end)+(1:delta_s_int)*skipFactor/Fs];
0305       <span class="keyword">end</span>
0306     <span class="keyword">else</span>
0307         roi
0308       error(&quot;can't concatenate discontinuous files with sample snap error of <span class="comment">%f seconds within timetol of %f seconds&quot;,...</span>
0309         abs(delta_s_int - delta_s)*skipFactor/Fs, timetol);
0310     <span class="keyword">end</span> 
0311   <span class="keyword">end</span>
0312     
0313   <span class="keyword">if</span> ~dryrun
0314     cfg1=[]; 
0315     cfg1.timetol = timetol; 
0316     cfg1.timeref = <span class="string">'common'</span>;
0317     cfg1.match_labels = match_labels;
0318     raw = <a href="../../bml/signal/bml_hstack.html" class="code" title="function [data] = bml_hstack(cfg, varargin)">bml_hstack</a>(cfg1, raw, next_raw);
0319     time = raw.time{1};
0320   <span class="keyword">else</span>
0321     time = [time next_time];
0322   <span class="keyword">end</span>
0323   
0324   file_raw_map = [file_raw_map;row];
0325 <span class="keyword">end</span>
0326 
0327 <span class="keyword">if</span> dryrun
0328   raw = [];
0329 <span class="keyword">elseif</span> ~isempty(electrode)
0330   <span class="comment">%changing labels from channels to electrodes</span>
0331   new_label = <a href="../../bml/utils/bml_map.html" class="code" title="function mapped = bml_map(element,domain,codomain,non_domain)">bml_map</a>(raw.label,electrode.channel,electrode.electrode,<span class="string">'NA'</span>);
0332   new_label(strcmp(new_label,<span class="string">'NA'</span>)) = raw.label(strcmp(new_label,<span class="string">'NA'</span>));
0333   raw.label = new_label; 
0334 <span class="keyword">end</span>
0335 
0336 file_raw_map = <a href="../../bml/annot/bml_roi_table.html" class="code" title="function roi=bml_roi_table(x, description, x_var_name)">bml_roi_table</a>(file_raw_map);
0337 
0338 
0339 
0340</pre></div>
<hr><address>Generated on Thu 31-Mar-2022 14:53:35 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>